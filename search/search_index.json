{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\ude80 Mycelium: The Ultimate API Gateway","text":"<p>Welcome to Mycelium API Gateway, the ultimate solution for secure, flexible, and multi-tenant API management! Whether you're building a robust platform or enhancing your downstream APIs, our gateway is designed to provide you with everything you need for seamless authentication, authorization, and security. \ud83c\udf89</p>"},{"location":"#key-features","title":"\ud83c\udf1f Key Features","text":""},{"location":"#ai-aware-api-gateway","title":"\ud83e\udde0 AI-aware API Gateway","text":"<ul> <li> <p>Service Discovery: Discover downstream APIs and their capabilities. Mycelium API Gateway is designed to be AI-aware, meaning it can understand the capabilities of the downstream APIs and use that information to route requests appropriately.</p> </li> <li> <p>Full control of downstream APIs: Downstream APIs can control whether they   routes should be discovered or not.</p> </li> <li> <p>Health Checks: Downstream APIs can define health checks to indicate when   they are ready to receive requests. Health status is automatically updated   based on the health checks and informed during discovery.</p> </li> </ul>"},{"location":"#authentication-authorization","title":"\ud83d\udd12 Authentication &amp; Authorization","text":"<ul> <li> <p>Oauth2: Support for any OAuth2 identity provider with a fell lines of   configuration.</p> </li> <li> <p>Two-Factor Authentication (2FA): Built-in support for TOTP to ensure an   extra layer of security when users opts to use the internal authentication   system.</p> </li> <li> <p>Federated Identity Support: Integrate with external identity providers   while maintaining full control over roles and permissions.</p> </li> <li> <p>Role-Based Access Control (RBAC): Define granular roles for both the   gateway and downstream APIs using simple YAML configurations.</p> </li> </ul>"},{"location":"#multi-tenant-architecture","title":"\ud83c\udfe2 Multi-Tenant Architecture","text":"<ul> <li> <p>Tenant Management: Create and manage tenants with subscription-based   accounts.</p> </li> <li> <p>Role Assignment: Invite users to join tenants and assign them specific   roles to streamline collaboration.</p> </li> </ul>"},{"location":"#secure-secrets-management","title":"\ud83d\udd11 Secure Secrets Management","text":"<ul> <li> <p>Vault Integration: Leverage HashiCorp Vault for secure storage of secrets.</p> </li> <li> <p>Flexible Configurations: Use secrets stored in Vault, environment   variables, or define them in YAML.</p> </li> <li> <p>Dynamic Secret Injection: Automate secure secret delivery to downstream   APIs.</p> </li> </ul>"},{"location":"#api-routing-webhooks","title":"\ud83c\udf10 API Routing &amp; Webhooks","text":"<ul> <li> <p>Smart API Routing: Easily configure API routes with support for secure   token-based authentication.</p> </li> <li> <p>Webhook Support: Define webhooks with secrets for secure callbacks and   notifications.</p> </li> </ul>"},{"location":"#yaml-driven-configuration","title":"\ud83d\udcc4 YAML-Driven Configuration","text":"<ul> <li> <p>Simple and Intuitive: Manage all configurations (tenants, roles,   permissions, routes, and security) with easy-to-read YAML files.</p> </li> <li> <p>Environment Flexibility: Combine YAML definitions with environment   variables for maximum flexibility.</p> </li> </ul>"},{"location":"#security-first-design","title":"\ud83d\udee1\ufe0f Security-First Design","text":"<ul> <li> <p>Downstream Security: Automatically pass role-based security credentials to   downstream APIs.</p> </li> <li> <p>Token Management: Store and securely pass tokens in request headers.</p> </li> <li> <p>Compliance Ready: Designed with modern security practices to meet   enterprise compliance requirements.</p> </li> </ul>"},{"location":"#why-choose-mycelium-api-gateway","title":"\ud83c\udfaf Why Choose Mycelium API Gateway?","text":"<ol> <li> <p>Community-Driven and Open Source: Leverage a growing community while    benefiting from an open-source model.</p> </li> <li> <p>Scalable and Modular: Designed to grow with your needs, from startups to    enterprise-scale applications.</p> </li> <li> <p>Developer-Friendly: YAML-based configurations, secure secret management,    and role-based policies make it easy to get started.</p> </li> </ol>"},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Postgres (Database for tenant and user management)</p> </li> <li> <p>Redis (Caching for performance)</p> </li> <li> <p>HashiCorp Vault (optional but recommended for secret management in   production environments)</p> </li> <li> <p>Docker (optional for quick deployment)</p> </li> </ul>"},{"location":"#join-the-community","title":"\ud83d\udcac Join the Community","text":"<ul> <li>GitHub Issues for   feedback and feature requests</li> </ul>"},{"location":"#star-us","title":"\ud83c\udf1f Star Us","text":"<p>If you find this project useful, please give us a \u2b50 on GitHub to support our growth and attract more contributors!</p>"},{"location":"#license","title":"License","text":"<p>Mycelium API Gateway is licensed under the Apache 2.0 License. Additional restrictions for commercial use apply under the Commons Clause.</p> <p>We can't wait to see how Mycelium API Gateway powers your next big project! \ud83d\ude80</p>"},{"location":"config/","title":"Mycelium API Gateway Configuration Guide","text":"<p>This document describes the configurations of the YAML file used to set up the server. An example file can be found in the <code>config.example.yaml</code> file.</p> <p>\ud83d\udd12 KEEP SAFE</p> <p>Mycelium provides three different ways to configure the execution environment:</p> <ol> <li>Directly in the YAML file (for development purposes).</li> <li>Environment variables (for production purposes but storing secrets as    environment variables).</li> <li>Externally in a Vault server (for production purposes, highly recommended    because the secrets are not exposed as environment variables).</li> </ol> <p>All of the three options are valid and can be used for any configuration, but we recommended users to use the Vault server to store the secrets in production environments.</p> <p>Example:</p> <p>Using directly in the YAML file:</p> <pre><code>tokenSecret: \"my-secret\"\n</code></pre> <p>Using environment variables:</p> <pre><code>tokenSecret:\n  env: MYC_TOKEN_SECRET\n</code></pre> <p>Using Vault:</p> <pre><code>tokenSecret:\n  vault:\n    path: myc/core/accountLifeCycle\n    key: tokenSecret\n</code></pre> <p>Mycelium will try to resolve the variables at runtime, so it is not necessary to restart the API Gateway after changing the configuration.</p> <p>In the next sections, we will describe the configurations options used to start the API Gateway.</p>"},{"location":"config/#1-vault-configurations-vault-highly-recommended-for-production-environments","title":"1. Vault Configurations (<code>vault</code>): Highly recommended for production environments","text":"<p>If users opt to use the Vault server to store the secrets, they should configure the following options:</p> <ul> <li><code>url</code>: The URL of the Vault server. Should include the protocol, hostname,   and port number if necessary.</li> <li><code>versionWithNamespace</code>: The API version used to interact with the Vault   server. Example: <code>v1/kv</code>.</li> <li><code>token</code>: The token used to authenticate with the Vault server. For obvious   reasons, this configuration should be performed using direct definition in the   YAML file (development) or environment variables (production).</li> </ul>"},{"location":"config/#2-core-configurations-core","title":"2. Core Configurations (<code>core</code>)","text":"<p>Here resides the core configurations of the API Gateway. Configs defined here should be used to configure the basic application lifecycle and webhooks.</p>"},{"location":"config/#21-account-lifecycle-accountlifecycle","title":"2.1 Account Lifecycle (<code>accountLifeCycle</code>)","text":"<ul> <li><code>domainName</code>: The human friendly name of the domain. Usually this is the   frontend domain name. Example: <code>Mycelium</code>.</li> <li><code>domainUrl</code>: The URL of the domain. Example: <code>https://mycelium.com</code>.</li> <li><code>tokenExpiration</code>: Token expiration time (in seconds).</li> <li><code>noreplyName</code> / <code>noreplyEmail</code>: Name and email for automatic messages.</li> <li><code>supportName</code> / <code>supportEmail</code>: Name and email for support.</li> <li><code>locale</code>: Default locale. Emails will be sent in this locale.</li> <li><code>tokenSecret</code>: A unique secret used to encrypt JWT tokens.</li> </ul>"},{"location":"config/#22-webhook-webhook","title":"2.2 Webhook (<code>webhook</code>)","text":"<ul> <li><code>acceptInvalidCertificates</code>: Allows self-signed certificates.</li> <li><code>consumeIntervalInSecs</code>: The interval in seconds between each batch of   webhook dispatch events.</li> <li><code>consumeBatchSize</code>: The number of events processed per batch.</li> <li><code>maxAttempts</code>: The maximum number of attempts to process an event.</li> </ul>"},{"location":"config/#3-sql-database-adapter-settings-diesel","title":"3. SQL Database Adapter Settings (<code>diesel</code>)","text":"<ul> <li><code>databaseUrl</code>: The database URL. This is recommended to be stored in the   Vault server.</li> </ul>"},{"location":"config/#4-notifier-adapter-settings-smtp-and-queue","title":"4. Notifier Adapter Settings (<code>smtp</code> and <code>queue</code>)","text":""},{"location":"config/#41-smtp-smtp","title":"4.1 SMTP (<code>smtp</code>)","text":"<ul> <li><code>host</code>: The SMTP server.</li> <li><code>username</code> / <code>password</code>: Smtp credentials.</li> </ul>"},{"location":"config/#42-email-queue-queue","title":"4.2 Email Queue (<code>queue</code>)","text":"<ul> <li><code>emailQueueName</code>: The name of the email queue.</li> <li><code>consumeIntervalInSecs</code>: The interval in seconds between each batch of   email dispatch events.</li> </ul>"},{"location":"config/#5-redis-settings-redis","title":"5. Redis Settings (<code>redis</code>)","text":"<p>Redis is used to store cache and session data.</p> <ul> <li><code>protocol</code>: The protocol used to connect to the Redis server.</li> <li><code>hostname</code>: The address of the Redis server.</li> <li><code>password</code>: The password used to connect to the Redis server.</li> </ul>"},{"location":"config/#6-authentication-settings-auth","title":"6. Authentication Settings (<code>auth</code>)","text":"<p>Mycelium provides a flexible authentication system that allows users to configure internal and external authentication providers. Internal authentication is the default authentication provider and is used to authenticate users against the Mycelium database. External authentication is used to authenticate users against any external provider that supports OAuth 2.0.</p>"},{"location":"config/#61-internal-authentication-internal","title":"6.1 Internal Authentication (<code>internal</code>)","text":"<ul> <li><code>jwtSecret</code>: A unique secret used to encrypt JWT tokens.</li> <li><code>jwtExpiresIn</code>: JWT expiration time.</li> <li><code>tmpExpiresIn</code>: Temporary token expiration time. This is used to generate   temporary tokens that are used during password reset and account creation   processes.</li> </ul>"},{"location":"config/#62-external-authentication-external","title":"6.2 External Authentication (<code>external</code>)","text":"<p>Here you can configure any external provider that supports OAuth 2.0. See example in <code>config.example.yaml</code>.</p> <ul> <li><code>issuer</code>: The issuer of the OAuth 2.0 provider. This is a URL that   identifies the provider.</li> <li><code>jwksUri</code>: The URI of the JWKS endpoint. This is a URL that points to the   JWKS (JSON Web Key Set) endpoint of the provider.</li> <li><code>userInfoUrl</code>: The URI of the user info endpoint. This is a URL that   points to the user info endpoint of the provider.</li> <li><code>audience</code>: The audience of the OAuth 2.0 provider. This is a string that   identifies the API that the provider is used for.</li> </ul>"},{"location":"config/#7-api-settings-api","title":"7. API Settings (<code>api</code>)","text":""},{"location":"config/#71-service-settings","title":"7.1 Service Settings","text":"<ul> <li><code>serviceIp</code>: Service IP address. Usually <code>0.0.0.0</code>.</li> <li><code>servicePort</code>: Service port. Usually <code>8080</code>.</li> <li><code>serviceWorkers</code>: Number of workers. Usually <code>4</code>.</li> <li><code>gatewayTimeout</code>: Gateway timeout. Usually <code>30</code> seconds.</li> <li><code>allowedOrigins</code>: List of allowed origins. Usually <code>*</code>.</li> <li><code>healthCheckInterval</code>: Health check interval. Usually <code>120</code> seconds.</li> <li><code>maxRetryCount</code>: Maximum retry count. Usually <code>3</code>.</li> <li><code>cache</code>: Cache settings. See below for more details.</li> <li><code>cache.jwksTtl</code>: JWKS cache TTL. Usually <code>3600</code> seconds.</li> <li><code>cache.emailTtl</code>: Email cache TTL. Usually <code>120</code> seconds.</li> <li><code>cache.profileTtl</code>: Profile cache TTL. Usually <code>120</code> seconds.</li> <li><code>allowedOrigins</code>: List of allowed origins. Usually <code>*</code> for development   purposes.</li> </ul>"},{"location":"config/#72-logging-settings-logging","title":"7.2 Logging Settings (<code>logging</code>)","text":"<ul> <li><code>level</code>: Log level for each module. See examples in   <code>config.example.yaml</code>. Values can be defined   globally or individually for each module.</li> <li><code>format</code>: Log format (jsonl/ansi).</li> <li><code>target</code>: Log destination (stdout/file/collector). See examples in   <code>config.example.yaml</code>.</li> </ul>"},{"location":"config/#73-tls-settings-tls","title":"7.3 TLS Settings (<code>tls</code>)","text":"<ul> <li><code>tlsCert</code> / <code>tlsKey</code>: TLS certificates. If stored in Vault, store the   raw values as strings.</li> </ul>"},{"location":"config/#74-route-configurations-routes","title":"7.4 Route Configurations (<code>routes</code>)","text":"<ul> <li><code>routes</code>: The file system path to the routes configuration file. See   <code>Routes Configuration</code> for more details.</li> </ul>"},{"location":"deploy-k8s/","title":"Deploy Mycelium API Gateway in Kubernetes with Helm","text":"<p>TODO</p>"},{"location":"deploy-locally/","title":"Deploy Mycelium API Gateway locally with docker compose","text":"<p>TODO</p>"},{"location":"downstream-apis/","title":"Management Endpoints","text":"<p>Downstream services are configured using a YAML file. An example of such a definition can be found in the <code>examples/routes.example.yaml</code> file.</p>"},{"location":"downstream-apis/#service-configuration","title":"Service Configuration","text":"<p>The service configuration is done in the <code>services</code> section of the YAML file. Each service is defined as a dictionary with the following keys:</p> <p>Required keys:</p> <ul> <li> <p><code>name</code>: The name of the service. This is used to identify the service and call   it from the gateway url path. Them, remember to define the service name using   kebab-case. Example: <code>my-service</code>.</p> </li> <li> <p><code>host</code> or <code>hosts</code>: The host(s) of the service. The host should include the   port number and ignore the protocol. It can be a single host or a vector of   hosts.</p> </li> <li> <p><code>protocol</code>: The protocol of the service. Example: <code>http</code> or <code>https</code>.</p> </li> <li> <p><code>routes</code>: This is an important field. Thus, it should be described in more   detail in the routes section.</p> </li> </ul> <p>Optional keys:</p> <ul> <li> <p><code>discoverable</code>: Whether the service is discoverable by LLM agents.</p> </li> <li> <p><code>secrets</code>: A list of named secrets that are used to authenticate mycelium with   the downstream service. Mycelium provides two types of secrets:</p> </li> <li> <p><code>queryParameter</code>: A query parameter in the request to the downstream     service. Query parameters will be added to the request as a query parameter.     It contains two fields:</p> <ul> <li><code>name</code>: The name of the query parameter.</li> <li><code>token</code>: The token to be used to authenticate the request.</li> </ul> </li> <li> <p><code>authorizationHeader</code>: An authorization header in the request to the     downstream service. Authorization headers will be added to the request as an     authorization header. It contains three fields:</p> <ul> <li><code>name</code>: The name of the authorization header.</li> <li><code>prefix</code>: The prefix of the authorization header.</li> <li><code>token</code>: The token to be used to authenticate the request.</li> </ul> </li> </ul> <p>[!NOTE] Mycelium supports the definition of secrets using environment variables and vault secrets. For both, the secret should be defined in a <code>JSON</code> format.</p> <p>Direct definition:</p> <pre><code>- name: secret-query-token\n  queryParameter:\n    name: \"token\"\n    token: \"my-secret-01\"\n- name: secret-authorization-header\n  authorizationHeader:\n    name: \"Authorization\"\n    prefix: \"Bearer \"\n    token: \"my-secret-01\"\n</code></pre> <p>Environment variable definition:</p> <pre><code>export MY_SECRET_01='{\"queryParameter\": {\"name\": \"token\",\"token\": \"my-secret-01\"}}'\n</code></pre> <pre><code>- name: secret-query-token\n  env: MY_SECRET_01\n</code></pre> <p>Vault secret definition:</p> <pre><code>- name: secret-query-token\n  vault: my-vault-path\n</code></pre> <p>Optional keys together with <code>discoverable</code> field:</p> <ul> <li> <p><code>id</code>: The id of the service. If not provided, the id will generated as a UUID   V3 from the <code>name</code> field. We highly recommend to set this field as an UUID V4   to guarantee the uniqueness and the replicability of the service.</p> </li> <li> <p><code>description</code>: The description of the service.</p> </li> <li> <p><code>openapiPath</code>: The path to the OpenAPI specification file.</p> </li> <li> <p><code>healthCheckPath</code>: The path to the health check endpoint.</p> </li> <li> <p><code>capabilities</code>: The capabilities of the service. A vector of strings that   describe the capabilities of the service. Example: if the service is an   authentication service, the capabilities could be <code>authenticate</code>, <code>Oauth2</code>,   <code>JWT</code>, etc.</p> </li> <li> <p><code>serviceType</code>: One of the following: <code>rest-api</code>, <code>unknown</code>. The type should be   written using kebab-case. New types can be added by opening an issue.</p> </li> <li> <p><code>isContextApi</code>: Whether the service is a context API or not. Context APIs are   used to describe the usage of the service in the context of the gateway. As   the authentication service is a context API, it is used to authenticate the   user before accessing the downstream service.</p> </li> </ul>"},{"location":"downstream-apis/#routes","title":"Routes","text":"<p>Downstream routes should be defined in the <code>routes</code> section. It is a vector of dictionaries. Each dictionary contains the following keys:</p> <p>Required keys:</p> <ul> <li><code>group</code>: The security group that will be used to protect the route. Currently,   seven security groups are supported:</li> <li> <p><code>public</code>: The route is public and does not require authentication. Example:</p> <pre><code>- group: public\n</code></pre> </li> <li> <p><code>authenticated</code>: The route is authenticated and requires a valid JWT token.     Mycelium will inject the user email into the request headers named     <code>x-mycelium-email</code> for the downstream service. Example:</p> <pre><code>- group: authenticated\n</code></pre> </li> <li> <p><code>protected</code>: Protected paths requires that users are authenticated and have     a valid profile registered in the gateway. THe full profile should be     injected as a request header named <code>x-mycelium-profile</code>. Example:</p> <pre><code>- group: protected\n</code></pre> </li> <li> <p><code>protectedByRoles</code>: Protected paths requires that users are authenticated     and received a valid role through the mycelium guest system. If the user     does not have a valid role, the request will be rejected with a 403 error.     The profile will be injected as a request header named <code>x-mycelium-profile</code>.     Example:</p> <pre><code>- group: !protectedByRoles\n    roles:\n      - admin\n</code></pre> </li> <li> <p><code>protectedByPermissionedRoles</code>: Protected paths requires that users are     authenticated and received a valid role through the mycelium guest system.     If the user does not have a valid role, the request will be rejected with a     403 error. The profile will be injected as a request header named     <code>x-mycelium-profile</code>. Example:</p> <pre><code>- group: !protectedByPermissionedRoles\n    permissionedRoles:\n      - [admin, write]\n      - [editor, read]\n</code></pre> </li> <li> <p><code>protectedByServiceTokenWithRole</code>: Mycelium already supports route     protection by service token with role. The definition is the same of the     <code>protectedByRoles</code> group. Example:</p> <pre><code>- group: !protectedByServiceTokenWithRole\n    roles:\n      - admin\n</code></pre> <p>To access the protected route, users should provide a valid service token. Service tokens are defined as connection strings that defines the roles that the service token should have. Example:</p> <pre><code>export MY_SERVICE_TOKEN='tid=c8282c6d-ce0b-4fed-a4e8-8e8a70f5b789;rid=8d7b119b-a12b-4ff1-9db0-5b6d05794282;r=newbie;edt=2025-01-11T21:51:01-03:00;sig=asd132f141e1...3a02f56bf0c4f123'\n</code></pre> <p>Connection strings should include information about tenant (tid), role (rid), the role name \u00ae, and expiration date (edt). The signature (sig) is used to verify the validity of the connection string. The role name \u00ae should be checked against the roles defined in the <code>protectedByServiceTokenWithRole</code> group.</p> </li> <li> <p><code>protectedByServiceTokenWithPermissionedRoles</code>: Mycelium already supports     route protection by service token with permissioned roles. The definition is     the same of the <code>protectedByPermissionedRoles</code> group. Example:</p> <pre><code>- group: !protectedByServiceTokenWithPermissionedRoles\n    permissionedRoles:\n      - [admin, write]\n      - [editor, read]\n</code></pre> <p>Service tokens are defined as connection strings that defines the roles that the service token has. Example:</p> <pre><code>export MY_SERVICE_TOKEN='tid=c8282c6d-ce0b-4fed-a4e8-8e8a70f5b789;rid=8d7b119b-a12b-4ff1-9db0-5b6d05794282;pr=newbie:0;edt=2025-01-11T21:51:01-03:00;sig=dcd32f141e1...3a02f56bf0c4f479'\n</code></pre> <p>Connection strings should include information about tenant (tid), role (rid), the permissioned role name (pr), and expiration date (edt). The signature (sig) is used to verify the validity of the connection string. The permissioned role name (pr = newbie with view permission) should be used to specify the permissioned role name that the service token should have.</p> </li> <li> <p><code>path</code>: The path of the route. Users can define as a wildcard. Example:</p> <pre><code>- group: public\n    path: /users/*\n</code></pre> </li> <li> <p><code>methods</code>: A list of HTTP methods that will be used to access the route. In   addition to default HTTP methods, users can use two reserved words, <code>ALL</code> and   <code>NONE</code>. The first one will match all the HTTP methods and the second one will   match none of the HTTP methods.</p> </li> </ul> <p>Optional keys:</p> <ul> <li><code>secretName</code>: Here users can simple reference the name of the secret defined at   the service level. Mycelium will resolve the secret at runtime.</li> </ul> <pre><code>- group: public\n    path: /users/*\n    secretName: secret-authorization-header\n</code></pre> <ul> <li><code>acceptInsecureRouting</code>: Whether the route should accept insecure routing.   This is usual when the downstream service is using a self-signed certificate.   It is important to note that this should be used with caution, avoiding to use   it when the downstream service is using a certificate signed by a trusted   certificate authority. Example:</li> </ul> <pre><code>- group: public\n    path: /users/*\n    acceptInsecureRouting: true\n</code></pre>"},{"location":"install/","title":"How to install and execute Mycelium API Gateway","text":"<p>This guide will walk you through the steps to install Mycelium API Gateway on your local machine. Mycelium API Gateway package includes twelve libs and services, available in Crates.io. It should be installed using the cargo package manager.</p>"},{"location":"install/#prerequisites","title":"Prerequisites","text":"<p>Before you start, make sure you have the following installed on your machine:</p> <ul> <li>Postgres (Database for tenant and user management)</li> <li>Redis (Caching for performance)</li> <li>HashiCorp Vault (optional but recommended for secret management in   production environments)</li> <li>Docker (optional for quick deployment)</li> </ul>"},{"location":"install/#installation-using-cargo","title":"Installation using cargo","text":"<p>The simplest way to install Mycelium API Gateway is to use the <code>cargo</code> package manager.</p> <pre><code>cargo install mycelium-api\n</code></pre> <p>Once installed, the simplest way to start the API Gateway is to run the following command:</p> <pre><code>SETTINGS_PATH=settings/config.example.yaml myc-api\n</code></pre> <p>Note that the environment variable <code>SETTINGS_PATH</code> is pointing to the settings file. For details of the settings file, please refer to the settings documentation.</p>"},{"location":"install/#installation-using-docker","title":"Installation using Docker","text":"<p>The easiest way to install Mycelium API Gateway is to use the Docker image.</p> <pre><code>docker pull sgelias/mycelium-api:latest\n</code></pre>"},{"location":"install/#initialize-postgres-database","title":"Initialize Postgres Database","text":"<p>Mycelium API Gateway uses Postgres as the main datastore. Thus, the first step to start the API Gateway is to initialize the Postgres database. To do this, first guarantee that you have a Postgres instance running. Then, you can use the <code>postgres/sql/up.sql</code> script to initialize the database using the following command with the <code>psql</code> utility's with the <code>-v</code> option to pass the database password:</p> <pre><code>psql postgres://postgres:postgres@localhost:5432/postgres \\ \n  -f postgres/sql/up.sql \\ \n  -v db_password='REPLACE_ME'\n</code></pre> <p>Replace the connection string with your own Postgres connection string. Note the <code>postgres</code> database is used to initialize the connection, however the script itself creates an alternative database named <code>mycelium-v7-dev</code> as default.</p> <p>The database name is configurable using the <code>db_name</code> variable in the <code>up.sql</code> script. Example:</p> <pre><code>psql postgres://postgres:postgres@localhost:5432/postgres \\ \n  -f postgres/sql/up.sql \\ \n  -v db_name='my-mycelium-database' \\ \n  -v db_password='REPLACE_ME'\n</code></pre> <p>Additional arguments customizations should be done in the <code>up.sql</code> script to set the <code>db_user</code> and <code>db_role</code> variables. Default values are <code>mycelium-v7-user</code> and <code>service-role-mycelium-v7</code> respectively.</p>"},{"location":"install/#initialize-vault","title":"Initialize Vault","text":"<p>Vault is optional but recommended for secret management in production environments. To initialize Vault, use the standard Vault CLI commands to init and unseal the Vault.</p> <pre><code>vault operator init\n</code></pre> <p>As output, you will get the root token and the keys to unseal the Vault.</p> <pre><code>Unseal Key 1: REPLACE_ME\nUnseal Key 2: REPLACE_ME\nUnseal Key 3: REPLACE_ME\nUnseal Key 4: REPLACE_ME\nUnseal Key 5: REPLACE_ME\n\nInitial Root Token: REPLACE_ME\n</code></pre> <p>Once the Vault is initialized, you can unseal it using the following command:</p> <pre><code>vault operator unseal\n</code></pre> <p>For more information on how to use Vault, please refer to the official Vault documentation.</p> <p>Lets code and be happy!</p>"},{"location":"webhooks/","title":"Configure webhooks","text":"<p>TODO</p>"}]}